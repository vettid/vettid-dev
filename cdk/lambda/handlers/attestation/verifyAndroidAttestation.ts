import { APIGatewayProxyEventV2, APIGatewayProxyResultV2 } from 'aws-lambda';
import { DynamoDBClient, GetItemCommand, UpdateItemCommand } from '@aws-sdk/client-dynamodb';
import { marshall, unmarshall } from '@aws-sdk/util-dynamodb';
import {
  ok,
  badRequest,
  notFound,
  conflict,
  internalError,
  parseJsonBody,
  getRequestId,
  putAudit,
} from '../../common/util';
import {
  verifyAndroidAttestation,
  meetsSecurityRequirements,
  AndroidAttestationData,
} from '../../common/attestation';

const ddb = new DynamoDBClient({});

const TABLE_ENROLLMENT_SESSIONS = process.env.TABLE_ENROLLMENT_SESSIONS!;

interface VerifyAndroidRequest {
  enrollment_session_id: string;
  certificate_chain: string[];  // Base64-encoded DER certificates
}

/**
 * POST /vault/enroll/attestation/android
 *
 * Verify Android Hardware Key Attestation during enrollment.
 *
 * The mobile app sends the certificate chain generated by KeyStore.
 * We verify:
 * 1. Certificate chain is valid and roots to Google
 * 2. Key Attestation Extension contains our challenge
 * 3. Attestation level meets security requirements (TEE or StrongBox)
 */
export const handler = async (event: APIGatewayProxyEventV2): Promise<APIGatewayProxyResultV2> => {
  const requestId = getRequestId(event);

  try {
    const body = parseJsonBody<VerifyAndroidRequest>(event);

    if (!body.enrollment_session_id) {
      return badRequest('enrollment_session_id is required');
    }
    if (!body.certificate_chain || body.certificate_chain.length === 0) {
      return badRequest('certificate_chain is required');
    }

    // Get enrollment session
    const sessionResult = await ddb.send(new GetItemCommand({
      TableName: TABLE_ENROLLMENT_SESSIONS,
      Key: marshall({ session_id: body.enrollment_session_id }),
    }));

    if (!sessionResult.Item) {
      return notFound('Enrollment session not found');
    }

    const session = unmarshall(sessionResult.Item);

    // Validate session state
    if (session.status !== 'STARTED') {
      return conflict(`Invalid session status: ${session.status}`);
    }

    if (session.step !== 'attestation_required') {
      return conflict(`Invalid session step: ${session.step}. Expected attestation_required.`);
    }

    // Check session expiry
    if (new Date(session.expires_at) < new Date()) {
      return badRequest('Enrollment session has expired');
    }

    // Get the challenge that was sent to the device
    const challenge = session.attestation_challenge;
    if (!challenge) {
      return conflict('No attestation challenge found in session');
    }

    // Verify the attestation
    const attestationData: AndroidAttestationData = {
      certificateChain: body.certificate_chain,
      challenge: challenge,
    };

    const result = await verifyAndroidAttestation(attestationData);

    // Check if attestation meets requirements
    if (!meetsSecurityRequirements(result)) {
      await putAudit({
        type: 'attestation_failed',
        user_guid: session.user_guid,
        session_id: body.enrollment_session_id,
        device_type: 'android',
        security_level: result.securityLevel,
        errors: result.errors,
      }, requestId);

      return badRequest(`Attestation verification failed: ${result.errors.join(', ')}`);
    }

    const now = new Date();

    // Update session with attestation result
    await ddb.send(new UpdateItemCommand({
      TableName: TABLE_ENROLLMENT_SESSIONS,
      Key: marshall({ session_id: body.enrollment_session_id }),
      UpdateExpression: 'SET #step = :step, attestation_verified = :verified, attestation_result = :result, attestation_verified_at = :verified_at',
      ExpressionAttributeNames: {
        '#step': 'step',
      },
      ExpressionAttributeValues: marshall({
        ':step': 'password_required',
        ':verified': true,
        ':result': {
          deviceType: result.deviceType,
          securityLevel: result.securityLevel,
          details: result.details,
        },
        ':verified_at': now.toISOString(),
      }),
    }));

    // Audit log
    await putAudit({
      type: 'attestation_verified',
      user_guid: session.user_guid,
      session_id: body.enrollment_session_id,
      device_type: 'android',
      security_level: result.securityLevel,
    }, requestId);

    return ok({
      status: 'attestation_verified',
      device_type: 'android',
      security_level: result.securityLevel,
      next_step: 'password_required',
      password_key_id: session.password_key_id,
    });

  } catch (error: any) {
    console.error('Android attestation error:', error);
    return internalError('Failed to verify attestation');
  }
};
